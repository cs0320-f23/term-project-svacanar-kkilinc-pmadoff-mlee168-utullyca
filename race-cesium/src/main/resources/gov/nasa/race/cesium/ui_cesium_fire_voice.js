/**
 * Questions:
 * 
 * Define entry classes for the data (sub-entries for satelliete image, call and metadata)
 * 
 */

import * as config from "./config.js"; // generated by scala

//The ws.js file could be dynamically generated on the server-side (by Scala or another backend language) 
// and served to the client when requested. This is often done for config files or files that contain sensitive logic.
import * as ws from "./ws.js";
import * as util from "./ui_util.js";
import * as ui from "./ui.js";
import * as uiCesium from "./ui_cesium.js";


// smoke entry definition
const defaultContourRender = initDefaultColors(config.smokelayer.contourRender); // creates a constant of the render - used for reseting display
var currentContourRender = initDefaultColors(config.smokelayer.contourRender); // creates a variable of the render - used for changing display

// Define the distinct types to render throughout the UI (like an ENUM for type safety)
// stored in the different entry types to identify (then queried later for actions)
const SmokeLayerType = { // values for smoke and cloud to be used throughout
    SMOKE: "smoke",
    CLOUD: "cloud"
}
// status signal
const LOADED = "○";
const SHOWING = "●";

// Entry class - each entry represents a satellite image and has a smoke and cloud sub entry
class Entry {
    // factory method - creates each specific layer type
    // it is a factory method because we define a method and the subclasses ovveride this at instantion time
    // the subclass implemenationf of the factory method will create objects 
    static create (smokeLayer) {
        return new Entry(smokeLayer); //
    }
    static compareFiltered (a,b) { // used to make the entry list stay in order
            switch (util.compare(a.date,b.date)) {
                case -1: return 1;
                case 0: return util.compare(a.satellite, b.satellite);
                case 1: return -1;
            }
    }

    constructor(smokeLayer) {
        this.id = smokeLayer.uniqueId // gets unique id for storing entries
        this.date = smokeLayer.date; // date and time from data
        this.satellite = smokeLayer.satellite; // satellite from data
        this.srs = smokeLayer.srs; // srs from data

        //The actual creation logic for different SmokeCloudEntry types (SmokeEntry and CloudEntry) is encapsulated within the 
        //SmokeCloudEntry class itself, not scattered around in the client code or other classes.
        // Uses the ENUM to create two different objects from the same data (we could have the logic for both in one class but we decided to seperate here)
        this.smokeEntry = SmokeCloudEntry.create(smokeLayer, SmokeLayerType.SMOKE) // creates smoke entry
        this.cloudEntry = SmokeCloudEntry.create(smokeLayer, SmokeLayerType.CLOUD) // creates cloud entry
    }

    clear() { // clears both layers for an entry
        this.smokeEntry.SetVisible(false);
        this.cloudEntry.SetVisible(false);
        uiCesium.requestRender();

    }

    renderChanged () { // updates render for both layers of an entry
        this.smokeEntry.renderChanged();
        this.cloudEntry.renderChanged();
    }

}

// SmokeCloudEntry class - parent class for stored smoke and cloud layers
class SmokeCloudEntry {
    // factory method - creates each specific layer type
    // the factory method is used to create object of various types and we use it here to encapulsate the creation logic, making it easy to extned
    // when we handle the websocket messages we can use the factory method to create the correct type of object
    // like: let se = SmokeCloudEntry.create(smokeLayer, someType) 
    static create (smokeLayer, type) {
        if (type == SmokeLayerType.SMOKE) return new SmokeEntry(smokeLayer);
        if (type == SmokeLayerType.CLOUD) return new CloudEntry(smokeLayer);
    }

    // From the JSON that is pushed over the websocket we get this information
    constructor(smokeLayer, type) {
        // come from server message
        this.date = smokeLayer.date; // date and time from data
        this.satellite = smokeLayer.satellite; // satellite from data
        this.srs = smokeLayer.srs; // srs from data
        this.url = undefined; // where to get data
        this.dataSource = undefined; // where the ceisum dataset is stored
        this.render = {...currentContourRender}; // current rendering conditions on the layer
        this.show = false; // default not showing
    }

    setStatus (newStatus) { // changes status from loaded to showing
        this.status = newStatus;
    }

    SetVisible (showIt) { // function to set layers visible
        if (showIt != this.show) { // runs block if change in showing
            this.show = showIt; // updates member variable to new showing condition
            if (showIt) {
                if (!this.dataSource) { // loads data source if it has not been loaded yet
                    this.loadContoursFromUrl(); // this is async, it will set vectorPrimitives when done
                } else { // uses preloaded data source
                    this.dataSource.show = true;
                    uiCesium.requestRender(); // updates render
                }
                this.setStatus( SHOWING);
            }
        }
        if (showIt == false) {
            if (this.dataSource) { // hides data source
                this.dataSource.show = false;
                uiCesium.requestRender();
                this.setStatus( LOADED);
            }
        }
    }

    async loadContoursFromUrl() { // handles new data source
        let renderOpts = this.getRenderOpts(); // get rendering options
        //console.log("@@DEBUG ", this.url);
        let response = await fetch(this.url); // pulls data from the server hosting it - see route definition in service
        let data = await response.json();
        Cesium.GeoJsonDataSource.load(data, renderOpts).then(  // loads data into a cesium data source object
            ds => {
                //console.log("@@DEBUG got data", this.url);
                this.dataSource = ds;
                this.postProcessDataSource(); // updates fill colors
                uiCesium.addDataSource(ds); // adds data source to cesium
                uiCesium.requestRender(); // updates the render
            }
        );
    }

    getRenderOpts() { // provides default render options
        return {
            stroke: this.render.strokeColor,
            strokeWidth: this.render.strokeWidth,
            alpha: this.render.alpha,
            clampToGround: false
        };
    }

    postProcessDataSource() { // post processes the entities or polygons in the data source
        let entities = this.dataSource.entities.values;
        let render = this.render;
        for (const e of entities) { // update each entities color to match smoke/cloud colors
            if (this.type == SmokeLayerType.SMOKE) {
                e.polygon.material = this.render.smokeColor;
            }
            if (this.type == SmokeLayerType.CLOUD) {
                e.polygon.material = this.render.cloudColor;
            }
            e.polygon.outline = true;
            e.polygon.outlineColor = this.render.strokeColor;
            e.polygon.outlineWidth = this.render.strokeWidth;
        }
    }

    renderChanged() { // updates render parameters according to user input
        this.render = {...currentContourRender}; // updates render parameters
        this.getRenderOpts();
        if (this.dataSource) {
            this.postProcessDataSource(); // updates data fill
            uiCesium.requestRender(); // requests new render
        }
    }
}

class SmokeEntry extends SmokeCloudEntry { // child class for smoke entry
    constructor (smokeLayer) {
        super(smokeLayer); // invoking the constructor of their parent class SmokeCloudEntry.
        
        //add additional fields for the specific type of entry
        this.smokeFile = smokeLayer.smokeFile;
        this.url = smokeLayer.smokeUrl;
        this.type =  SmokeLayerType.SMOKE; // smoke or cloud 
    
    }
}

class CloudEntry extends SmokeCloudEntry { // child class for cloud entry
    constructor (smokeLayer) {
        super(smokeLayer); // invoking the constructor of their parent class SmokeCloudEntry.
        this.cloudFile = smokeLayer.cloudFile;
        this.url = smokeLayer.cloudUrl;
        this.type =  SmokeLayerType.CLOUD; // smoke or cloud
    }
}

// initialization

const smokeCloudEntries = new Map(); // unique-key -> Entries; stores Entry objects

var displayEntries = []; // instantiates variable used for temp entry storage
var selectedEntry = undefined; // instantiates variable used for temp entry selection
var selectedType = ["smoke", "cloud"]; // instantiates list of selected layers
var selectedSat = ["G16", "G18"]; // instantiates list of selected satellites
var followLatest = config.smokelayer.followLatest; // instantiates followlatest boolean

var smokeSelection = { // object for storing entry selections in selection panel
    show: true,
    type: SmokeLayerType.SMOKE,
    sat: undefined,
    date: undefined,
};

var cloudSelection = { // object for storing entry selections in selection panel
    show: true,
    type: SmokeLayerType.CLOUD,
    sat: undefined,
    date: undefined,
};

// Use the ENUM again to define the entry selections 
const selectionEntries = new Map([ // unique-key -> selections; stores selection objects
    [SmokeLayerType.SMOKE, smokeSelection],
    [SmokeLayerType.CLOUD, cloudSelection]
]);

// UI initialization
initWindow();
initCheckBoxes();

var entryView = initEntryView(); // variable storing Entries - modify this to add or remove entries
var selectionView = initSelectionView(); // variable storing selections - modify this to change selections

ws.addWsHandler(handleWsSmokeLayerMessages); // adds handler to websocket

//--- end module init

function initWindow() {
    createIcon();
    createWindow();
    initContourDisplayControls();
    console.log("ui_cesium_smokelayer initialized");
}

function createIcon() {
    console.log("created smoke icon");
    return ui.Icon("smoke-icon.svg", (e)=> ui.toggleWindow(e,'smoke'));
}

function initCheckBoxes() { // init checkboxes to their default values
    ui.setCheckBox("smoke.followLatest", followLatest);
    ui.setCheckBox("smoke.G16", selectedSat.includes("G16"));
    ui.setCheckBox("smoke.G17", selectedSat.includes("G17"));
    ui.setCheckBox("smoke.G18", selectedSat.includes("G18"));
}

function initEntryView() { // creates entry view list object
    let view = ui.getList("smokelayer.entries"); // sets identifier
    if (view) {
        ui.setListItemDisplayColumns(view, ["header"], [
            { name: "sat", tip: "name of satellite", width: "5.5rem", attrs: [], map: e => e.satellite },
            { name: "date", width: "11rem", attrs: ["fixed", "alignLeft"], map: e => util.toLocalMDHMString(e.date)},
        ]);
    }
    return view;
}

function initSelectionView() { // creates selection view list object
    let view = ui.getList("smokelayer.selection"); // sets identifies
    if (view) {
        ui.setListItemDisplayColumns(view, ["header"], [
            { name: "show", tip: "toggle visibility", width: "2.5rem", attrs: [], map: e => ui.createCheckBox(e.show, toggleShowSource) },
            { name: "type", tip: "type of entry", width: "4rem", attrs: [], map: e => e.type },
            { name: "sat", tip: "name of satellite", width: "3rem", attrs: [], map: e => e.sat },
            { name: "date", width: "7rem", attrs: ["fixed", "alignLeft"], map: e => util.toLocalMDHMString(e.date)},
        ]);
    }
    return view;
}

function createWindow() { // creates window
    return ui.Window("Smoke and Cloud Layers", "smoke", "smoke-icon.svg")(
        ui.Panel("Data Selection", true)( // data selection panel
            ui.RowContainer()(
                ui.CheckBox("G16", selectSatellite, "smoke.G16"), // name, action on click, tracking id
                ui.CheckBox("G17", selectSatellite, "smoke.G17"),
                ui.CheckBox("G18", selectSatellite, "smoke.G18"),
            ),
            ui.RowContainer()(
                ui.CheckBox("follow latest", toggleFollowLatest, "smoke.followLatest"), // name, action on click, tracking id
                ui.Button("clear", clearSelections) // name, action on click
            ),
            ui.List("smokelayer.selection", 3) // tracking id, number of visible rows
        ),
        ui.Panel("Data Entries", true)( // data entry panel
            ui.List("smokelayer.entries", 6, selectSmokeCloudEntry), // tracking id, number of visible rows, action on click
            ui.ListControls("smokelayer.entries")
        ),
        ui.Panel("Contour Display")( // contour display panel
            ui.Button("reset", resetDisplaySelections),
            ui.Slider("alpha", "smoke.contour.alpha", contourAlphaChanged),
            ui.Slider("stroke width", "smoke.contour.stroke_width", contourStrokeWidthChanged),
            ui.ColorField("stroke color", "smoke.contour.stroke_color", true, contourStrokeColorChanged), // label, id, is input, action on click
            ui.ColorField("smoke color", "smoke.contour.smoke_color", true, contourFillColorChanged),
            ui.ColorField("cloud color", "smoke.contour.cloud_color", true, contourFillColorChanged),
        ),
    );
 }

function initContourDisplayControls() {

    let e = ui.getSlider("smoke.contour.alpha"); // get slider from id
    ui.setSliderRange(e, 0, 1.0, 0.1); //  set range
    ui.setSliderValue(e, defaultContourRender.alpha); // set value

    let s = ui.getSlider("smoke.contour.stroke_width");
    ui.setSliderRange(s, 0, 3, 0.5);
    ui.setSliderValue(s, defaultContourRender.strokeWidth);

    let sc = ui.getField("smoke.contour.stroke_color"); // get color field from id
    ui.setField(sc, convertColorToStripAlpha(defaultContourRender.strokeColor)); // set color field value

    let colorSmoke = ui.getField("smoke.contour.smoke_color");
    ui.setField(colorSmoke, convertColorToStripAlpha(defaultContourRender.smokeColor));

    let colorCloud = ui.getField("smoke.contour.cloud_color");
    ui.setField(colorCloud, convertColorToStripAlpha(defaultContourRender.cloudColor));
}

//--- contour controls
function initDefaultColors(renderConfig) { // resets colors to default according to a config
    let width = renderConfig.strokeWidth;
    let alpha = renderConfig.alpha;
    let strokeColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.strokeColor), alpha);
    let smokeColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.smokeColor), alpha);
    let cloudColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.cloudColor), alpha);
    let result = {strokeWidth:width, strokeColor:strokeColor, cloudColor:cloudColor, smokeColor:smokeColor, alpha:alpha};//fillColors: fillColors, alpha:alpha};
    return result
}

function contourStrokeWidthChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let n = ui.getSliderValue(event.target);
        currentContourRender.strokeWidth = n;
        e.renderChanged();
    }
}

function contourStrokeColorChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let clrSpec = event.target.value;
        if (clrSpec) {
            currentContourRender.strokeColor =  convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
            e.renderChanged();
        }
    }
}

function contourFillColorChanged(event) {
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        let clrSpec = event.target.value;
        let boxSpec = event.target.id;
        if (clrSpec) { // changes render color according to the fill box changed
            if (boxSpec == "smoke.contour.smoke_color") {
                currentContourRender.smokeColor = convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
            }
            if (boxSpec == "smoke.contour.cloud_color") {
                 currentContourRender.cloudColor = convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
            }
            e.renderChanged();
        }
    }
    updateColors();
    uiCesium.requestRender();
}

function convertColorToHaveAlpha(color, alpha){
    return Cesium.Color.fromAlpha(Cesium.Color.fromCssColorString(color.slice(0,7)), alpha);
}

function convertColorToStripAlpha(color) {
    return color.toCssHexString().slice(0,7)
}

function updateColors(){ // updates color from user input
    let sColor = currentContourRender.smokeColor; // get color
    let sColorNoAlpha = convertColorToStripAlpha(sColor); // strip current alpha
    currentContourRender.smokeColor =  convertColorToHaveAlpha(sColorNoAlpha, currentContourRender.alpha);
    let cColor = currentContourRender.cloudColor; // get color
    let cColorNoAlpha = convertColorToStripAlpha(cColor); // strip current alpha
    currentContourRender.cloudColor =  convertColorToHaveAlpha(cColorNoAlpha, currentContourRender.alpha);
}

function contourAlphaChanged(event) {
    let v = ui.getSliderValue(event.target);
    currentContourRender.alpha = v;
    // update colors with new alpha
    updateColors();
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        e.renderChanged();
    }
}

function resetDisplaySelections(event) { // resets display settings to default
    currentContourRender = initDefaultColors(config.smokelayer.contourRender);
    updateColors();
    initContourDisplayControls();
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) {
        selectedEntry.renderChanged();
    }

}

// interactions - behavior for clicking boxes and filtering entries
function clearSelections(event){
    // clear viewed data
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) selectedEntry.clear();
    clearEntries();
    clearSelectionView();
    // clear all checkboxes
    followLatest = false;
    updateEntryView();
    initCheckBoxes();
}

function toggleFollowLatest(event) {
    followLatest = ui.isCheckBoxSelected(event.target);
    if ((followLatest==true) && (ui.getSelectedListItemIndex(entryView) != 0)) {
        ui.selectFirstListItem(entryView);
    }
}

function toggleShowSource(event) { // from data selection checkboxes
    let cb = ui.getCheckBox(event.target)
    let cbName = ui.getListItemOfElement(cb).type;
    if (cbName == SmokeLayerType.CLOUD) selectCloudEntries(event); // updates according to the checkbox
    if (cbName == SmokeLayerType.SMOKE) selectSmokeEntries(event); // updates according to the checkbox
    let e = ui.getSelectedListItem(entryView);
    if (e) { // sets selected layers visible and unselected to not visible
        if (selectedType.includes(SmokeLayerType.SMOKE)) selectedEntry.smokeEntry.SetVisible(true);
        else selectedEntry.smokeEntry.SetVisible(false);
        if (selectedType.includes(SmokeLayerType.CLOUD)) selectedEntry.cloudEntry.SetVisible(true);
        else selectedEntry.cloudEntry.SetVisible(false);

    }
}
function selectSmokeCloudEntry(event) { // selects entry from the data entry list
    selectedEntry = ui.getSelectedListItem(entryView);
    if (selectedEntry) {
        if (selectedType.includes(SmokeLayerType.SMOKE)) selectedEntry.smokeEntry.SetVisible(true);
        if (selectedType.includes(SmokeLayerType.CLOUD)) selectedEntry.cloudEntry.SetVisible(true);
        updateSelectionView(selectedEntry);
    }
    else {
        clearEntries(); // ensure all entries are cleared if nothing is selected
    }
}


function updateSelectionView(selectedEntry) { // updates selections to match the selected entry
    let sat = selectedEntry.satellite;
    let date = selectedEntry.date;
    selectionEntries.get("smoke").sat = sat;
    selectionEntries.get("smoke").date = date;
    selectionEntries.get("cloud").sat = sat;
    selectionEntries.get("cloud").date = date;
    displayEntries = util.filterMapValues(selectionEntries, se=> isSelectedEntry(selectedEntry, se));
    ui.setListItems(selectionView, displayEntries);
}

function clearSelectionView() { // clears selections
    selectionEntries.get("smoke").sat = undefined;
    selectionEntries.get("smoke").date = undefined;
    selectionEntries.get("cloud").sat = undefined;
    selectionEntries.get("cloud").date = undefined;
    ui.setListItems(selectionView, selectionEntries);

}

function isSelectedEntry(selectedEntry, selectionEntry) { // checks if the selection matches the selected entry
    return ((selectedEntry.date == selectionEntry.date) && (selectedEntry.satellite = selectionEntry.sat));
}

function selectCloudEntries(event) { // selects cloud layers by updating selected type variable
    if (ui.isCheckBoxSelected(event.target)){
        if (!selectedType.includes("cloud")) selectedType.push("cloud");
    }
    else {
        var index = selectedType.indexOf("cloud");
        if (index > -1) {
            selectedType.splice(index, 1);
        }
    }
}

function selectSatellite(event) { // selects visible satellites to filter entry list
    let cb = ui.getCheckBox(event.target);
    let satName = ui.getCheckBoxLabel(cb)
    if (ui.isCheckBoxSelected(event.target)){
        if (!selectedSat.includes(satName)) selectedSat.push(satName);
    }
    else {
        // update satellite list
        var index = selectedSat.indexOf(satName);
        if (index > -1) {
            selectedSat.splice(index, 1);
        }
        // clear all entries visible from that sat
    }
    let e = ui.getSelectedListItem(entryView);
    if (e) {
        if (!selectedSat.includes(e.satellite)) {
            e.clear();
            clearSelectionView();
        }
    }
    updateEntryView();
    if (followLatest == true) ui.selectFirstListItem(entryView);
}

function selectSmokeEntries(event) { // selects smoke layers by updating selected type variable
    if (ui.isCheckBoxSelected(event.target)){
            if (!selectedType.includes("smoke")) selectedType.push("smoke");
        }
    else {
        var index = selectedType.indexOf("smoke");
        if (index > -1) {
            selectedType.splice(index, 1);
        }
    }
}

function updateEntryView() { // updates entry view
    displayEntries = util.filterMapValues(smokeCloudEntries, se=> isSelected(se));
    displayEntries.sort(Entry.compareFiltered); // need to fix sorting
    ui.setListItems(entryView, displayEntries);
}

function isSelected (se) { // checks if entries are selected
    return selectedSat.includes(se.satellite)
}

// websocket messages

// The function that serves as the main entry point for handling WebSocket messages related to smoke layers.
// The function takes in two arguments: msgType representing the type of the message and msg containing the actual message payload.
function handleWsSmokeLayerMessages(msgType, msg) { 
    switch (msgType) { // Switch on the type of message received
        case "smokeLayer":
            // If the message is of type "smokeLayer", then handle the smoke layer message.
            handleSmokeLayerMessage(msg.smokeLayer); 
            return true; // Returns true to indicate that the message was successfully processed.
        default:
            return false; // Returns false to indicate that the message type was not recognized.
    }
}

// Clears all the entries and sets visibility of both smoke and cloud entries to false.
function clearEntries() { 
    smokeCloudEntries.forEach((value, key) => { // Iterates over each entry in smokeCloudEntries
        value.clear(); // Clears the individual entry
        value.smokeEntry.SetVisible(false); // Sets the smoke entry visibility to false
        value.cloudEntry.SetVisible(false); // Sets the cloud entry visibility to false
    });
}

// This function processes an individual smoke layer message.
// The function takes in smokeLayer, which contains the data for a single smoke layer.
function handleSmokeLayerMessage(smokeLayer) { 
    // when we call 
    let se = Entry.create(smokeLayer); // Creates a new Entry object from the received smokeLayer data
    smokeCloudEntries.set(smokeLayer.id, se); // Stores the new entry in the smokeCloudEntries map using its id as the key

    if (isSelected(se)) updateEntryView(); // If the new entry is selected, updates the entry view.

    if (followLatest == true) { // Checks if followLatest flag is set to true
        clearEntries(); // Clears all currently visible entries
        ui.selectFirstListItem(entryView); // Selects the first entry in the entry view. Note: It implies the need to deselect the current entry.
    }
}
