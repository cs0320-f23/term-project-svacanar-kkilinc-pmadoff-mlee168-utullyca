/**
 * Based off of the ui_cesium_smoke.js class written by NASA engineers to
 * connect the SmokeServiceActor to the Cesium front-end.
 * for sofi
 */

/**
 * Import statements ui_cesium_smoke.js
 */
console.log("Starting to load the FireVoiceLayer script...");

import * as config from "./config.js"; // generated by scala
import * as ws from "./ws.js";
import * as util from "./ui_util.js";
import * as ui from "./ui.js";
import * as uiCesium from "./ui_cesium.js";
console.log("Import statements processed in FireVoiceLayer script.");
console.log("Importing config:", config);

// constant of the fire voice layer for initial rendering
const defaultContourRender = initDefaultColors(config.fireVoiceLayer.contourRender);
// var to change the display
var currentContourRender = initDefaultColors(config.fireVoiceLayer.contourRender);
console.log("Default contour render config:", config.fireVoiceLayer.contourRender);

/**
 * Constants adapted from ui_cesium_smoke.js
 */
const fireVoiceLayerType = {PERIM : "perim", TEXT:"text"}
const LOADED = "○";
const SHOWING = "●"



/**
 * Adapted from ui_cesium_smoke.js
 * Each entry represents a satellite image
 * Creates a new entry for the fire voice layer (smoke layer in cesium_smoke)
 */
class Entry{
  static create (fireVoiceLayer){
    return new Entry(fireVoiceLayer);
  }

  // This needs to be changed with the FireVoiceLayer class objects
  /**
   static compareFiltered (a,b) { // used to make the entry list stay in order
   switch (util.compare(a.date,b.date)) {
   case -1: return 1;
   case 0: return util.compare(a.satellite, b.satellite); // this can't be used
   case 1: return -1;
   }
   */
  constructor(fireVoiceLayer) {
    this.id = fireVoiceLayer.id; //uniqueID before
    this.date = fireVoiceLayer.date;
    this.incidentId = fireVoiceLayer.Incident_ID;
    this.callID = fireVoiceLayer.Call_ID;
    // this.satellite = fireVoiceLayer.satellite;
    // this.srs = fireVoiceLayer.srs;
    this.perimEntry = FireVoiceEntry.create(fireVoiceLayer, fireVoiceLayerType.PERIM); //GeoJson
    // This has to be represented within a label to  visualize the text on the map
    this.textEntry = FireVoiceEntry.create(fireVoiceLayer, fireVoiceLayerType.TEXT); // Text
  }

  /**
   * This is the function that is called when the user clicks on the entry
   * It clears the current entry and sets the visibility to false
   */
  clear() {
    this.perimEntry.setVisible(false);
    if (this.textEntry instanceof FireTextEntry && this.textEntry.textEntity) {
      uiCesium.viewer.entities.remove(this.textEntry.textEntity);
      this.textEntry.textEntity = null;
    }
    uiCesium.requestRender();
  }

  /**
   * Updates the render for both layers of an entry
   */
  renderChanged () {
    this.perimEntry.renderChanged();
    this.textEntry.renderChanged();
  }
}

/**
 * FireVoiceEntry class - parent class for stored perim and text layers
 */

class FireVoiceEntry {
  static create(fireVoiceLayer, type) {
    console.log("Initializing FireVoiceEntry:", fireVoiceLayer, "Type:", type);
    if (type == fireVoiceLayerType.PERIM) return new FirePerimEntry(
        fireVoiceLayer);
    if (type == fireVoiceLayerType.TEXT) return new FireTextEntry(
        fireVoiceLayer);

  }

  /**
   * From the JSON that is pushed over the websocket we get this information
   * @param fireVoiceLayer - the JSON object that is pushed over the websocket
   * @param type - the type of layer (perim or text)
   */
  constructor(fireVoiceLayer, type) {
    this.id = fireVoiceLayer.id;
    this.date = fireVoiceLayer.date;
    this.incidentId = fireVoiceLayer.Incident_ID;
    this.callId = fireVoiceLayer.Call_ID;
    this.coordinates = fireVoiceLayer.Coordinates; // This is an array of objects
    this.incidentReport = fireVoiceLayer.Incident_Report;
    this.severityRating = fireVoiceLayer.Severity_Rating;
    this.coordinateType = fireVoiceLayer.Coordinate_Type;
    this.show = false;

    // URLs
    this.fireTextUrl = fireVoiceLayer.fireTextUrl;
    this.firePerimUrl = fireVoiceLayer.firePerimUrl;
    this.simReportUrl = fireVoiceLayer.simReportUrl;

    // this.satellite = fireVoiceLayer.satellite;  probably uses satellite for the geojson layer but what about the text layer?
    // this.srs = fireVoiceLayer.srs;
    this.url = type === fireVoiceLayerType.PERIM ? this.firePerimUrl : this.fireTextUrl;
    this.dataSource = undefined;
    this.render = {...currentContourRender};

    console.log("FireVoiceEntry Fields:", this);

  }

  /**
   * Sets the visibility of the layer
   * @param newStatus - boolean value of whether or not the layer is visible
   */
  setStatus(newStatus) {
    console.log("Setting status:", newStatus);
    this.status = newStatus;
  }

  /**
   * Sets the visibility of the layer
   * @param showIt - boolean value of whether or not the layer is visible
   */
  async setVisible(showIt) {
    const entryType = this instanceof FirePerimEntry ? "FirePerimEntry" : "FireTextEntry";
    console.log(`${this.id} (${entryType}): Setting visibility - initial: ${showIt}`);

    // For FireTextEntry, handling text entity removal if needed
    if (!showIt && this.textEntity && entryType === "FireTextEntry") {
      console.log(`${this.id} (${entryType}): Removing existing text entity.`);
      uiCesium.viewer.entities.remove(this.textEntity);
      this.textEntity = null;
    }

    this.show = showIt;
    console.log(`${this.id} (${entryType}): Updated 'this.show' to: ${this.show}`);

    if (showIt) {
      console.log(`${this.id} (${entryType}): showIt is true. Checking dataSource...`);
      if (!this.dataSource) {
        console.log(`${this.id} (${entryType}): DataSource is not set. Loading data...`);
        if (entryType === "FirePerimEntry") {
          console.log(`${this.id} (${entryType}): Loading contours...`);
          await this.loadContoursFromUrl().catch(error => console.error(`${this.id}: Error loading contours:`, error));
        } else if (entryType === "FireTextEntry") {
          console.log(`${this.id} (${entryType}): Loading text data...`);
          await this.loadTextDataFromUrl().catch(error => console.error(`${this.id}: Error loading text data:`, error));
        } else {
          console.log(`${this.id} (${entryType}): Instance type not recognized.`);
        }
      } else {
        console.log(`${this.id} (${entryType}): DataSource already set. Making dataSource visible.`);
        this.dataSource.show = true;
        uiCesium.requestRender();
      }
    } else {
      console.log(`${this.id} (${entryType}): showIt is false. Checking dataSource for hiding...`);
      if (this.dataSource) {
        console.log(`${this.id} (${entryType}): DataSource exists. Making dataSource invisible.`);
        this.dataSource.show = false;
        uiCesium.requestRender();
      } else {
        console.log(`${this.id} (${entryType}): No dataSource to hide.`);
      }
    }
  }

  async loadTextDataFromUrl() {
    if (!this.fireTextUrl || !this.show) {
      console.log("Text URL not provided or entry not visible.");
      return;
    }

    console.log("Loading text data from URL:", this.fireTextUrl);
    let response = await fetch(this.fireTextUrl);
    console.log("Received response for text:", response);

    if (response.ok) {
      let textData = await response.text();
      if (this.show) { // Ensure that the text is still meant to be shown
        this.displayText(textData);
      }
    } else {
      console.log("Failed to load text data:", response.status);
    }
  }



  /**
   * Loads the contours from the url
   * Can we use the same function as cesium_smoke since they deal with the map in a similar way?
   * @returns {Promise<void>}
   */
  async loadContoursFromUrl() { // handles new data source
    console.log("Loading contours from URL:", this.url);
    let renderOpts = this.getRenderOpts(); // get rendering options
    //console.log("@@DEBUG ", this.url);
    let response = await fetch(this.url); // pulls data from the server hosting it - see route definition in service
    console.log("Received response for contours:", response);

    let data = await response.json();
    console.log("Contour data loaded:", data);

    Cesium.GeoJsonDataSource.load(data, renderOpts).then(  // loads data into a cesium data source object
        ds => {
          //console.log("@@DEBUG got data", this.url);
          this.dataSource = ds;
          this.postProcessDataSource(); // updates fill colors
          console.log("perim: postPRocessDatasoure called")
          uiCesium.addDataSource(ds); // adds data source to cesium
          console.log("perim: addDataSource called")
          uiCesium.requestRender(); // updates the render
          console.log("perim: requestRender called")
        }
    );
  }

  /**
   * Gets the render options for the layer
   * @returns {{strokeWidth: (number|string|*), alpha: *, stroke: *, clampToGround: boolean}} - the render options
   */
  getRenderOpts() { // provides default render options

    return {
      stroke: this.render.strokeColor,
      strokeWidth: this.render.strokeWidth,
      alpha: this.render.alpha,
      clampToGround: false
    };
  }

  /**
   * Post processes the entities or polygons in the data source
   * Changed from cesium_smoke to only handle the perim layer since the text layer is a label
   * Empty and will be overridden by the perim child class
   */
  postProcessDataSource() {
    console.log("Post processing data source for type:");

    /**
     postProcessDataSource() { // post processes the entities or polygons in the data source
     let entities = this.dataSource.entities.values;
     let render = this.render;
     for (const e of entities) { // update each entities color to match smoke/cloud colors
     if (this.type == fireVoiceLayerType.PERIM) {
     e.polygon.material = this.render.smokeColor;
     }

     // TODO: Change this rendering (need to be for text)
     if (this.type == fireVoiceLayerType.TEXT) {
     e.polygon.material = this.render.cloudColor;
     }
     e.polygon.outline = true;
     e.polygon.outlineColor = this.render.strokeColor;
     e.polygon.outlineWidth = this.render.strokeWidth;
     }
     }
     */
  }

  /**
   * Displays the text on the map
   * Empty and will be overridden by the text child class
   */
  displayText() {
    console.log("Displaying text for fireVoiceLayer:");

  }

  /**
   * Updates the render parameters according to user input
   */
  renderChanged() {
    console.log("Render Change Alert")
    this.render = {...currentContourRender}; // updates render parameters
    this.getRenderOpts();
    if (this.dataSource) {
      this.postProcessDataSource(); // updates data fill
      uiCesium.requestRender(); // requests new render
    }
  }
}

/**
 * Sofi Will be here LOL
 */
class FirePerimEntry extends FireVoiceEntry {
  constructor(fireVoiceLayer) {
    super(fireVoiceLayer, fireVoiceLayerType.PERIM);

    console.log(`FirePerimEntry initialized: ID=${this.id}, URL=${this.url}`);
  }

  postProcessDataSource() {
    let entities = this.dataSource.entities.values;
    for (const e of entities) { // update each entities color to match smoke/cloud colors
      e.polygon.material = this.render.smokeColor;
      e.polygon.outline = true;
      e.polygon.outlineColor = this.render.strokeColor;
      e.polygon.outlineWidth = this.render.strokeWidth;
    }
  }
}

/**
 * FireTextEntry class - child class for text layer
 * This is the class that will be used to display the text on the map
 */
class FireTextEntry extends FireVoiceEntry {
  constructor(fireVoiceLayer) {
    super(fireVoiceLayer, fireVoiceLayerType.TEXT);
    this.textEntity = null;
    console.log(`FireTextEntry initialized: ID=${this.id}, Text URL=${this.fireTextUrl}`);
  }

// This is what I want to change the view for lowk
  /**
   * Displays the text on the map
   * @param textData - the text data that is displayed on the map
   */
  displayText(textData) {
    if (!textData) {
      console.log("No text data to display.");
      return;
    }

    // Remove existing text entity if present
    if (this.textEntity) {
      uiCesium.viewer.entities.remove(this.textEntity);
      this.textEntity = null;
    }

    // Assuming coordinates is an array with one element for simplicity
    const coord = this.coordinates[0];
    const position = Cesium.Cartesian3.fromDegrees(coord.longitude, coord.latitude);
    const textEntity = new Cesium.Entity({
      position: position,
      label: {
        text: textData,
        font: "12px sans-serif",  // Reduced font size
        fillColor: Cesium.Color.WHITE,
        outlineColor: Cesium.Color.BLACK,
        outlineWidth: 4,
        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
        pixelOffset: new Cesium.Cartesian2(0, -9),
        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      }
    });

    uiCesium.viewer.entities.add(textEntity);
    this.textEntity = textEntity
    // Enhanced logging
    console.log(`Text displayed on the map for Entry ID ${this.id}:`, textData);
    console.log(`Coordinates used: Longitude = ${coord.longitude}, Latitude = ${coord.latitude}`);
    console.log(`Related FireText URL: ${this.fireTextUrl}`);
    console.log(`Related TextEntity: ${this.textEntity}`);

  }
  clearTextData() {
    if (this.textEntity) {
      uiCesium.viewer.entities.remove(this.textEntity);
      this.textEntity = null;
    }
  }
}

// Initialize filters with default non-matching values
var incidentIdFilter = "no-match";
var callIdFilter = "no-match";


/**
 * FireVoiceLayer class - parent class for the fire voice layer
 * @type {Map<any, any>}
 */
let filteredDataEntries = new Set();
const fireVoiceDataEntries = new Map(); // unique-key -> Entries; stores Entry objects
console.log("FireVoiceLayer data entries:", fireVoiceDataEntries);
var fireVoiceDataDetailView = undefined;

var displayEntries = []; // Variable for temporary entry storage
var selectedEntry = undefined; // Variable for temporary entry selection
// var selectedType = ["perim", "text"]; // List of selected layers
// var selectedSat = ["G16", "G17", "G18"]; // List of selected satellites
var followLatest = config.fireVoiceLayer.followLatest; // Boolean flag for followLatest

var fireVoiceDataDetailView = ui.getKvTable("fireVoiceLayer.fireVoiceData");
console.log("Initializing fireVoiceDataDetailView ",fireVoiceDataDetailView);

/**
 * Object for storing entry selections in selection panel
 * @type {{date: undefined, show: boolean, type: string}}
 */
var perimSelection = {
  show: false,
  type: fireVoiceLayerType.PERIM,
  date: undefined,
};
console.log("perimSelection:", perimSelection);

/**
 * Object for storing entry selections in selection panel
 * @type {{date: undefined, show: boolean, type: string}}
 */
var textSelection = {
  show: false, //was true
  type: fireVoiceLayerType.TEXT,
  date: undefined,
};
console.log("textSelection:", textSelection);

console.log("Creating selectionEntries map...");
/**
 * Use the ENUM again to define the entry selections
 * @type {Map<string, {date: undefined, show: boolean, type: string}>}
 */
const selectionEntries = new Map([ // Unique-key -> selections; stores selection objects
  [fireVoiceLayerType.PERIM, perimSelection],
  [fireVoiceLayerType.TEXT, textSelection]
]);
console.log("selectionEntries:", selectionEntries);

// UI initialization
console.log("Initializing the UI...");
/**
 * Initializes the window
 */
initWindow(); // Initializes the window
console.log("UI initialized successfully.");

var fvEntryView = initFireVoiceDataView(); // Variable storing Entries - modify this to add or remove entries
console.log("initFireVoiceDataView initialized:", fvEntryView);

ws.addWsHandler(handleWsFireLayerMessages); // Adds a handler to the WebSocket
console.log("WebSocket handler added.");

//--- end module initialization

/**
 * Initializes the window for the fire voice layer
 */
// For instance, inside the initWindow function, you would add:
function initWindow() {
  console.log("Initializing FireVoiceLayer window...");
  createIcon();
  createWindow();
  initContourDisplayControls();
  updateEntryView();
  initializeFalse();
  console.log("FireVoiceLayer window initialized.");
}

/**
 * Creates the icon for the fire voice layer window
 * @returns {*}
 */
function createIcon() {

  console.log("created smoke icon");
  return ui.Icon("firehistory-icon.svg", (e)=> ui.toggleWindow(e,'smoke'));
}


/////////// /** SEKAI was here
// Function to update the data view panel
// New function to initialize the data view panel
// New function to initialize the data view panel for fire voice data

var selectedFvDataEntry = undefined; // To track the selected Fire Voice data entry

console.log(fireVoiceDataDetailView);

function initFireVoiceDataView() {
  console.log("Initializing FireVoiceDataView...");
  let view = ui.getList("fireVoiceLayer.fireVoiceData"); // Identifier for the new list
  if (view) {
    ui.setListItemDisplayColumns(view, ["header"], [
      { name: "incidentId", tip: "Incident ID", width: "6rem", attrs: [], map: e => e.incidentId },
      { name: "date", tip: "Date", width: "8rem", attrs: ["fixed", "alignLeft"], map: e => validateAndConvertDate(e.date) },
      { name: "callId", tip: "Call ID", width: "5rem", attrs: [], map: e => e.callID },
    ]);
  }
  ui.setListItems(view, Array.from(fireVoiceDataEntries.values())); // Populate the list with current entries
  console.log("FireVoiceDataView initialized with entries:", fireVoiceDataEntries);
  fireVoiceDataDetailView = view;
  return view;
}

function validateAndConvertDate(dateString) {
  if (isNaN(Date.parse(dateString))) {
    console.error("Invalid date string:", dateString);
    return "Invalid Date";
  }
  return util.toLocalMDHMString(new Date(dateString));
}

function selectedFvData(event) {
  console.log("Selected Fire Voice data item:", event);
  selectedFvDataEntry = ui.getSelectedListItem(fvEntryView);
  console.log("selectedFvDataEntry:", selectedFvDataEntry);
  if (selectedFvDataEntry) {
    console.log("Updating data view for selected entry");
    updateDataView();
  }
}

function updateDataView() {
  console.log("Updating data view...");
  if (selectedFvDataEntry) {
    let details = getFvDataItems(selectedFvDataEntry);
    console.log("updateDataView: Details to display:", details);
    ui.setKvList(fireVoiceDataDetailView, details);
  } else {
    console.log("No selected entry. Clearing data view.");
    ui.clearList(fireVoiceDataDetailView);
  }
}

function getFvDataItems(entry) {
  console.log("Getting data items for entry:", entry);
  return [
    ["ID", entry.id],
    ["Incident ID", entry.incidentId],
    ["Call ID", entry.callID],
    ["Date", entry.date],
  ];
}

// Function to refresh the FireVoice data view with new entries from the fireVoiceDataEntries map
function refreshFireVoiceDataView() {
  console.log("Attempting to Refresh FireVoiceDataView...");
  console.log(fireVoiceDataDetailView);

  if (fireVoiceDataDetailView) {
    // Populate the existing view with the updated list of entries
    ui.setListItems(fireVoiceDataDetailView, Array.from(fireVoiceDataEntries.values()));
    console.log("Refreshed FireVoiceDataView with updated entries:", fireVoiceDataEntries);
  } else {
    console.error("FireVoiceDataDetailView is not initialized.");
  }
  // Optional: Log the current state of fireVoiceDataEntries for debugging
  printFireVoiceDataEntries();
}
//////// /** SEKAI was here

/**
 * Creates the window
 * @returns {*}
 */
function createWindow() {
  console.log("Window created.");
  return ui.Window("Fire Voice Generated Perimeters", "smoke", "firehistory-icon.svg")(

      ui.Panel("Filter Data")(
          ui.TextField("Incident ID", "filter.incidentId", incidentIdChanged),
          ui.TextField("Call ID", "filter.callId", callIdChanged),
          ui.Button("Apply Filters", applyFilters)
      ),
      //TODO: Make a UI with that displays the current data available:
      // It should be able to display based on the incident_id
      // Make an a full implementation
      // New panel for Fire Voice Data
      ui.Panel("Fire Voice Data")(
          ui.TabbedContainer()(
              ui.Tab("All Entries", true)( ui.List("fireVoiceLayer.fireVoiceData", 5, selectedFvData) )
              // Additional tabs can be added here
          )
      ),
      ui.Panel("Contour Display")( // Contour display panel
          ui.Button("reset", resetDisplaySelections),
          ui.Slider("alpha", "smoke.contour.alpha", contourAlphaChanged),
          ui.Slider("stroke width", "smoke.contour.stroke_width", contourStrokeWidthChanged),
          ui.ColorField("stroke color", "smoke.contour.stroke_color", true, contourStrokeColorChanged),
          ui.ColorField("smoke color", "smoke.contour.smoke_color", true, contourFillColorChanged),
          ui.ColorField("cloud color", "smoke.contour.cloud_color", true, contourFillColorChanged)
      )
      // Additional panels or UI elements can be added here if needed
  );
}


function incidentIdChanged(event) {

}

function callIdChanged(event) {

}

function applyFilters() {
  // Directly get values from input fields
  incidentIdFilter = document.getElementById("filter.incidentId").value;
  callIdFilter = document.getElementById("filter.callId").value;

  console.log("Applying filters:", { incidentIdFilter, callIdFilter });

  updateEntryView();
}


async function updateEntryView() {
  console.log('**************************** Update Entry View *************************');
  console.log("Updating entry view with filters:", { incidentIdFilter, callIdFilter });
  let visibilityPromises = [];

  // Reset the filteredDataEntries set
  filteredDataEntries.clear();

  // First, apply filters to populate filteredDataEntries
  fireVoiceDataEntries.forEach(entry => {
    const matchesFilter = (!incidentIdFilter || entry.incidentId === incidentIdFilter) &&
        (!callIdFilter || entry.callID === callIdFilter);

    if (matchesFilter) {
      filteredDataEntries.add(entry.id);
    }
  });

  // Log all the filtered entry IDs
  console.log("Filtered entry IDs:", Array.from(filteredDataEntries));

  // Then, iterate over fireVoiceDataEntries to set visibility
  fireVoiceDataEntries.forEach(entry => {
    const shouldBeVisible = filteredDataEntries.has(entry.id);
    visibilityPromises.push(entry.perimEntry.setVisible(shouldBeVisible));
    visibilityPromises.push(entry.textEntry.setVisible(shouldBeVisible));
  });

  // Log all the awaiting promises
  console.log("Awaiting visibility promises:", visibilityPromises);

  // Await all promises for visibility setting
  await Promise.all(visibilityPromises);
  console.log("Finished Awaiting All Promises");

  refreshFireVoiceDataView();
  // Request UI render after all visibility changes
  uiCesium.requestRender();




  console.log('**************************** END: Update Entry View *************************');
}

function initializeFalse() {
  console.log("Initializing all entries to false visibility...");

  fireVoiceDataEntries.forEach(entry => {
    console.log(`Setting visibility to false for Entry ID ${entry.id}`);

    if (entry.perimEntry) {
      console.log(`- Perimeter entry for ID ${entry.id}`);
      entry.perimEntry.setVisible(false);
    } else {
      console.log(`- No Perimeter entry found for ID ${entry.id}`);
    }

    if (entry.textEntry) {
      console.log(`- Text entry for ID ${entry.id}`);
      entry.textEntry.setVisible(false);
    } else {
      console.log(`- No Text entry found for ID ${entry.id}`);
    }
  });

  console.log("All entries set to invisible.");
}


//

/**
 * resets the display settings to default
 * @param event
 */
function resetDisplaySelections(event) {
  currentContourRender = initDefaultColors(config.fireVoiceLayer.contourRender);
  updateColors();
  initContourDisplayControls();
  selectedEntry = ui.getSelectedListItem(entryView);
  if (selectedEntry) {
    selectedEntry.renderChanged();
  }
}

/**
 * Interactions - behavior for clicking boxes and filtering entries
 * @param event
 */
function clearSelections(event){
  // clear viewed data
  selectedEntry = ui.getSelectedListItem(entryView);
  if (selectedEntry) selectedEntry.clear();
  clearEntries();
  clearSelectionView();
  // clear all checkboxes
  followLatest = false;
  updateEntryView();
  updateDataView();
}



/**
 * Updates selections to match the selected entry
 * @param selectedEntry
 */
function updateSelectionView(selectedEntry) {
  let sat = selectedEntry.satellite;
  let date = selectedEntry.date;
  selectionEntries.get("smoke").sat = sat;
  selectionEntries.get("smoke").date = date;
  selectionEntries.get("cloud").sat = sat;
  selectionEntries.get("cloud").date = date;
  displayEntries = util.filterMapValues(selectionEntries, se=> isSelectedEntry(selectedEntry, se));
  ui.setListItems(selectionView, displayEntries);
}

/**
 * Clears the selections
 */
function clearSelectionView() {
  selectionEntries.get("smoke").sat = undefined;
  selectionEntries.get("smoke").date = undefined;
  selectionEntries.get("cloud").sat = undefined;
  selectionEntries.get("cloud").date = undefined;
  ui.setListItems(selectionView, selectionEntries);
}

function isSelectedEntry(selectedEntry, selectionEntry) { // checks if the selection matches the selected entry
  return ((selectedEntry.date == selectionEntry.date) && (selectedEntry.satellite = selectionEntry.sat));
}

function selectCloudEntries(event) { // selects cloud layers by updating selected type variable
  if (ui.isCheckBoxSelected(event.target)){
    if (!selectedType.includes("cloud")) selectedType.push("cloud");
  }
  else {
    var index = selectedType.indexOf("cloud");
    if (index > -1) {
      selectedType.splice(index, 1);
    }
  }
}


function isSelected (se) { // checks if entries are selected
  return selectedSat.includes(se.satellite)
}
// Clears all the entries and sets visibility of both smoke and cloud entries to false.
function clearEntries() {
  console.log("Clearing entries...");
  fireVoiceDataEntries.forEach((value, key) => { // Iterates over each entry in fireVoiceDataEntries
    value.clear(); // Clears the individual entry
    value.perimEntry.setVisible(false); // Sets the smoke entry visibility to false
    value.textEntry.setVisible(false); // Sets the cloud entry visibility to false
  });
}
function printFireVoiceDataEntries() {
  console.log("************Printing fireVoiceDataEntries: ************");
  fireVoiceDataEntries.forEach((entry, id) => {
    console.log(`Entry with ID ${id}:`, entry);
  });
  console.log("******************************************************");

}

// websocket messages

// The function that serves as the main entry point for handling WebSocket messages related to smoke layers.
// The function takes in two arguments: msgType representing the type of the message and msg containing the actual message payload.
// TODO: confused on how this works. the JSON pushed over the websocket does not have an explicity message type
// ex: s"""{"msgType": "fireVoiceLayer", "fireVoiceLayer": {"id": "$id", "satellite":"$satellite", "date":${date.toEpochMillis}, "srs":"$srs", "smokeUrl":"$smokeUrl", "fireTextUrl":"$cloudUrl"}}"""
// Inside the WebSocket message handler:
function handleWsFireLayerMessages(msgType, msg) {
  console.log("Received WebSocket message:", msgType, msg);
  switch (msgType) {
    case "fireVoiceLayer":
      console.log("Handling fireVoiceLayer message...");
      handleFireLayerMessage(msg.fireVoiceLayer);
      console.log("FireVoiceLayer message handled.");
      return true;
      // ... rest of the cases
    default:
      console.warn("Unhandled message type:", msgType);
      return false;
  }
}


// This function processes an individual smoke layer message.
// The function takes in fireVoiceLayer, which contains the data for a single smoke layer.
function handleFireLayerMessage(fireVoiceLayer) {
  console.log("Received fireVoiceLayer data:", fireVoiceLayer);
  let entry = Entry.create(fireVoiceLayer);
  console.log("Created new Entry object:", entry);
  fireVoiceDataEntries.set(fireVoiceLayer.id, entry);
  console.log("Stored the new entry in fireVoiceDataEntries map with id:", fireVoiceLayer.id);
  refreshFireVoiceDataView();
  printFireVoiceDataEntries()
  // Update the view to reflect new data based on current filters
  updateEntryView();
  updateDataView();

}


////////
/**
 * Initializes the contour display
 */
function initContourDisplayControls() {

  let e = ui.getSlider("smoke.contour.alpha"); // Get slider from id
  ui.setSliderRange(e, 0, 1.0, 0.1); // Set range
  ui.setSliderValue(e, defaultContourRender.alpha); // Set value

  let s = ui.getSlider("smoke.contour.stroke_width");
  ui.setSliderRange(s, 0, 3, 0.5);
  ui.setSliderValue(s, defaultContourRender.strokeWidth);

  let sc = ui.getField("smoke.contour.stroke_color"); // Get color field from id
  ui.setField(sc, convertColorToStripAlpha(defaultContourRender.strokeColor)); // Set color field value

  let colorSmoke = ui.getField("smoke.contour.smoke_color");
  ui.setField(colorSmoke, convertColorToStripAlpha(defaultContourRender.smokeColor));

  let colorCloud = ui.getField("smoke.contour.cloud_color");
  ui.setField(colorCloud, convertColorToStripAlpha(defaultContourRender.cloudColor));

  console.log("Contour display controls initialized.");
}

/**
 * Initializes the default colors.
 * @param renderConfig
 * @returns {{strokeWidth: (*|number|string), cloudColor: *, alpha: (*|number|AlphaOption|boolean), smokeColor: *, strokeColor: *}}
 */
//--- Contour controls
function initDefaultColors(renderConfig) {
  let width = renderConfig.strokeWidth;
  let alpha = renderConfig.alpha;
  let strokeColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.strokeColor), alpha);
  let smokeColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.smokeColor), alpha);
  let cloudColor = convertColorToHaveAlpha(convertColorToStripAlpha(renderConfig.cloudColor), alpha);
  let result = { strokeWidth: width, strokeColor: strokeColor, cloudColor: cloudColor, smokeColor: smokeColor, alpha: alpha }; // Fill colors: fillColors, alpha: alpha};
  console.log("Default colors initialized:", result);
  return result;
}

function contourStrokeWidthChanged(event) {
  let e = ui.getSelectedListItem(entryView);
  if (e) {
    let n = ui.getSliderValue(event.target);
    currentContourRender.strokeWidth = n;
    e.renderChanged();
    console.log("Contour stroke width changed:", n);
  }
}


function contourStrokeColorChanged(event) {
  let e = ui.getSelectedListItem(entryView);
  if (e) {
    let clrSpec = event.target.value;
    if (clrSpec) {
      currentContourRender.strokeColor =  convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
      e.renderChanged();
    }
  }
}

/**
 * Updates the colors of the contours
 * @param event
 */
function contourFillColorChanged(event) {
  let e = ui.getSelectedListItem(entryView);
  if (e) {
    let clrSpec = event.target.value;
    let boxSpec = event.target.id;
    if (clrSpec) { // changes render color according to the fill box changed
      if (boxSpec == "smoke.contour.smoke_color") {
        currentContourRender.smokeColor = convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
      }
      if (boxSpec == "smoke.contour.cloud_color") {
        currentContourRender.cloudColor = convertColorToHaveAlpha(clrSpec, currentContourRender.alpha);
      }
      e.renderChanged();
    }
  }
  updateColors();
  uiCesium.requestRender();
}

/**
 * Updates the alpha of the contours
 * @param color - the color of the contours
 * @param alpha - the alpha of the contours
 * @returns {*}
 */
function convertColorToHaveAlpha(color, alpha){
  return Cesium.Color.fromAlpha(Cesium.Color.fromCssColorString(color.slice(0,7)), alpha);
}

/**
 * Updates the alpha of the contours
 * @param color - the color of the contours
 * @returns {*}
 */
function convertColorToStripAlpha(color) {
  return color.toCssHexString().slice(0,7)
}

/**
 * Updates the alpha of the contours
 * @param event - the event that is triggered
 */
function updateColors(){ // updates color from user input
  let sColor = currentContourRender.smokeColor; // get color
  let sColorNoAlpha = convertColorToStripAlpha(sColor); // strip current alpha
  currentContourRender.smokeColor =  convertColorToHaveAlpha(sColorNoAlpha, currentContourRender.alpha);
  let cColor = currentContourRender.cloudColor; // get color
  let cColorNoAlpha = convertColorToStripAlpha(cColor); // strip current alpha
  currentContourRender.cloudColor =  convertColorToHaveAlpha(cColorNoAlpha, currentContourRender.alpha);
}

/**
 * Handles the messages from the websocket
 * @param event - the event that is triggered
 */
function contourAlphaChanged(event) {
  let v = ui.getSliderValue(event.target);
  currentContourRender.alpha = v;

  /**
   * Updates the colors with the alpha changes
   */
  updateColors();
  let e = ui.getSelectedListItem(entryView);
  if (e) {
    e.renderChanged();
  }
}